日志分析系统 loganalyzer
祝彦翔 22307130073


1 项目概述
本项目为数据结构与算法课程的大作业，实现了一个具有完整功能的日志分析系统。该系统运行于命令行环境，支持用户以交互方式读取并分析格式化的日志文件。核心功能包括时间窗口过滤、关键词搜索、模块错误统计、历史日志查询以及操作撤销等。在实现过程中采用数据结构包括双向链表、循环队列、二叉搜索树、栈快照等，并基于 KMP 算法实现字符串匹配。


2 技术方案
2.1 技术栈与开发环境
项目在Ubuntu 22.04操作系统上使用g++ 11.4.0编译器进行编译与测试。构建过程由简单的Makefile脚本管理，便于快速编译与清理。

2.2 核心数据结构与算法
2.2.1 双向链表
双向链表用于存储日志文件中的所有记录。相比单向链表，双向指针结构使得从任意位置的插入与删除操作更加高效，尤其是在需要随机访问删除特定行号的日志时。每个链表节点包含时间戳字符串、日志级别、模块标识、日志消息等文本信息，同时预先计算并存储一个数值型时间戳（timeKey），以便于在进行时间范围查询时通过数值比较而非字符串比较，从而提高查询效率。

2.2.2 循环队列
循环队列是固定容量的环形缓冲结构，在这个项目中用于维护最近1000条日志的指针。该设计允许后续日志覆盖最早的日志，自动维持一个滑动窗口。循环队列的核心优势在于空间复用：当队列满员时，新日志会自动覆盖最旧的记录，无需频繁内存重分配。内部通过head和tail两个索引指针管理位置，采用模运算进行处理。

2.2.3 二叉搜索树
二叉搜索树在本系统中专用于统计各模块的ERROR日志数量。树的键为模块名称，值为该模块的ERROR计数。当删除日志时，若被删日志为ERROR级别，则相应的计数递减。当计数降至零时，对应的树节点被移除。二叉搜索树的中序遍历可直接得到模块列表的字典序，之后通过一次插入排序按错误数降序排列，便于STATS命令的输出。

2.2.4 KMP 字符串匹配算法
KMP算法是一种高效的模式串匹配算法，相比暴力匹配具有更优的时间复杂度。核心思想是利用已匹配部分的信息，在匹配失败时跳过已知不会匹配的位置，从而避免重复比较。算法首先计算模式串的LPS数组记录模式串每个位置处最长前缀与后缀重叠长度。在匹配过程中，每当文本字符与模式字符不匹配时，通过查询LPS数组快速确定模式串下一个应该比较的位置，而无需重新开始匹配。

2.2.5 快照与撤销栈
为了支持UNDO功能，系统在每次DELETE操作前创建当前整个系统状态的快照。快照包含链表的完整深拷贝、BST、及指向拷贝链表节点的队列指针数组。这些快照被存储在一个容量为5的栈中，当用户执行UNDO命令时，最近的快照被弹出并取代当前状态。


3 代码架构与模块说明
3.1 主程序入口 (main.cpp)
主程序负责命令行交互循环与各个命令的分发调度。启动后，程序进入无限循环，从标准输入逐行读取用户命令，对命令进行解析，然后调用相应的命令处理函数。系统维护四个全局指针，分别指向当前的链表、循环队列、BST与撤销栈实例。LOAD命令会重新初始化所有数据结构，其他命令则在既有状态上进行操作。异常或无效行号、空数据结构等会被简单忽略或返回空结果。

3.2 链表与日志节点 (LinkedList.h / LinkedList.cpp)
LinkedList类封装了双向链表的操作接口。LogNode结构体定义了单条日志的数据格式：包括原始的时间戳字符串（"YYYY-MM-DD HH:MM:SS"）、timeKey、日志级别（INFO/WARN/ERROR）、模块名与消息体。链表提供了push_back与push_front用于插入，remove_at用于按行号删除。clear方法在链表析构或重新加载时被调用用来释放所有节点。parseTimeKey静态方法将timeKey解析为long long数值便于这里进行时间比较。formatFullLine方法将日志节点格式化为原始的字符串行输出。

3.3 循环队列 (CircularQueue.h / CircularQueue.cpp)
CircularQueue管理一个固定大小为1000的数组，数组元素为指向链表节点的指针。push方法在队列未满时正常入队，队列已满时覆盖最旧元素，cnt成员记录当前有效元素数，head和tail分别指向环形缓冲的起始和下次写入位置。removeNode方法被用于DELETE操作后从队列中删除对应指针（遍历队列再将非目标指针收集到临时数组，然后将临时数组内容写回队列）。getLastN方法用于RECENT命令，从队尾反向获取最近的N条日志指针。traverse方法则支持对队列中的每个节点应用给定的函数指针。

3.4 二叉搜索树 (BST.h / BST.cpp)
BST类管理一棵二叉搜索树，节点结构BSTNode含模块名、计数与左右孩子指针。insertError方法在加载日志时被调用，若模块已存在则计数加一，否则创建新节点。decrementError用于DELETE后更新计数，当计数降至零时删除节点（无孩子则直接删除，仅有一个孩子则用孩子替代，有两个孩子则用中序后继替代）。find方法用于查找特定模块。nodeCount与inorderCollect用于STATS命令，nodeCount返回树中的节点总数，inorderCollect将节点指针按中序收集到数组。STATS命令随后对数组进行错误数降序、模块名升序重新排列。

3.5 撤销栈与快照 (UndoStack.h / UndoStack.cpp)
UndoStack维护一个容量为5的快照数组。Snapshot结构体包含链表的深拷贝指针、BST、以及队列指针数组与其大小。push方法在栈满时丢弃最旧的快照并将新快照压入。pop方法返回栈顶快照。makeSnapshot函数在DELETE前被调用，执行完整的状态拷贝（遍历链表，然后为每个节点创建新的LogNode副本并插入拷贝链表，统计ERROR日志重建BST，最后从拷贝链表的末尾取出最近的日志指针填充队列数组。保证UNDO后队列最近日志顺序正确）。freeSnapshot用于内存释放。

3.6 KMP 算法实现 (KMP.h / KMP.cpp)
KMP类提供两个静态方法。computeLPS接收模式串与LPS数组指针，通过两指针技巧计算LPS值：len指针指向正在匹配的模式前缀，i指针遍历模式串，当pat[i] == pat[len]时，len递增并记录lps[i] = len，当不相等时，若len非零则回退至lps[len-1]，否则lps[i]=0。contains方法接收文本与模式串，先计算模式的LPS，然后在文本中进行匹配，维护i和j分别指向文本与模式的当前比较位置，当字符相等时双指针同时前进，当j到达模式末尾时返回true，当字符不相等时回退j至lps[j-1]，i则根据j是否为零决定是否前进。


4 编译与运行
4.1 编译命令
在项目根目录执行make，调用Makefile的运行方式，逐个编译所有源文件并链接生成可执行文件loganalyzer。清理编译内容可运行make clean。

4.2 运行方式与命令说明
编译完成后，可启动程序进入交互模式：./loganalyzer
程序启动后会进入无限命令循环，等待用户输入。命令如下：
LOAD <filename> - 从指定文件加载日志。加载前会清空所有现有数据，加载后显示读入的日志条数。
FILTER <start> <end> - 按时间范围过滤并输出日志，其中时间格式为YYYY-MM-DD_HH:MM:SS，且过滤范围为闭区间。
SEARCH <keyword> - 使用 KMP 算法在所有日志的消息字段中搜索关键词，搜索过程大小写敏感。程序输出匹配日志的总数及详细内容。
STATS - 统计各模块的 ERROR 日志数量，按数量降序输出，当数量相同时按模块名字典升序排列。
DELETE <index> - 按行号删除指定日志，同时更新所有相关链表、循环队列、BST，并将当前系统状态压入撤销栈
UNDO - 撤销上一次DELETE操作，将系统状态完全恢复至该删除操作执行前。最多可连续撤销5次。
RECENT <n> - 输出循环队列中最近的n条日志，其中n不超过1000
EXIT - 退出程序
此外，也可通过执行如./loganalyzer < test_commands.txt程序会按文件中的命令顺序依次执行，所有输出同样打印至标准输出。

4.3 开发环境与兼容性
本程序在Ubuntu 22.04操作系统、g++ 11.4.0编译器环境下开发和测试。若在其他平台或编译器版本上编译，可能需要进行相应的环境配置调整。


5 测试与运行结果
在本地使用课程提供的测试用例（包括test1.txt、kmp_test.txt、consistency.txt等）进行了完整的功能测试，程序的输出与要求示例完全相符，包括日志格式、统计结果、搜索结果的顺序与内容均保持一致。各项测试均通过，验证了数据结构的正确性与各命令的功能完整性。


6 已知问题
暂无发现问题
